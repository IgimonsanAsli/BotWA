const fs = require('fs-extra');
require('dotenv').config();
const path = require('path');
const config = require('./config/config');
const WhatsAppClient = require('./wa/whatsappClient');


// ASCII Art untuk tampilan startup
const asciiArt = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó              ‚ïë
‚ïë  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù              ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù               ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó               ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó              ‚ïë
‚ïë     ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù              ‚ïë
‚ïë                                                              ‚ïë
‚ïë               WhatsApp Bot - TikTok Downloader               ‚ïë
‚ïë                     Tanpa Watermark                          ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`;

class TikTokBot {
    constructor() {
        this.client = new WhatsAppClient();
        this.startTime = new Date();
    }

    async start() {
        try {
            console.clear();
            console.log(asciiArt);
            console.log('üöÄ Memulai TikTok WhatsApp Bot...\n');

            // Setup folders
            await this.setupFolders();
            
            // Initialize WhatsApp client
            console.log('üì± Menginisialisasi WhatsApp client...');
            await this.client.initialize();

            // Setup cleanup
            this.setupCleanup();

            // Setup monitoring
            this.setupMonitoring();

        } catch (error) {
            console.error('‚ùå Error starting bot:', error);
            process.exit(1);
        }
    }

    async setupFolders() {
        try {
            console.log('üìÅ Menyiapkan folder...');
            
            // Buat folder utama
            await fs.ensureDir(config.folders.downloads);
            await fs.ensureDir(config.folders.temp);
            await fs.ensureDir(config.folders.sessions);

            // Buat folder untuk setiap kategori
            for (const [key, category] of Object.entries(config.categories)) {
                const categoryPath = path.join(config.folders.downloads, category);
                await fs.ensureDir(categoryPath);
            }

            console.log('‚úÖ Folder berhasil disiapkan');
            this.displayFolderStructure();

        } catch (error) {
            console.error('‚ùå Error setting up folders:', error);
            throw error;
        }
    }

    displayFolderStructure() {
        console.log('\nüìÇ STRUKTUR FOLDER:');
        console.log('‚îú‚îÄ‚îÄ downloads/');
        for (const [key, category] of Object.entries(config.categories)) {
            console.log(`‚îÇ   ‚îú‚îÄ‚îÄ ${category}/`);
        }
        console.log('‚îú‚îÄ‚îÄ temp/');
        console.log('‚îî‚îÄ‚îÄ sessions/\n');
    }

    setupCleanup() {
        // Cleanup saat aplikasi ditutup
        process.on('SIGINT', async () => {
            console.log('\nüîÑ Membersihkan dan menutup bot...');
            
            try {
                // Bersihkan file temporary
                const tempFiles = await fs.readdir(config.folders.temp);
                for (const file of tempFiles) {
                    await fs.remove(path.join(config.folders.temp, file));
                }
                console.log('üóëÔ∏è  File temporary dibersihkan');
                
                // Tampilkan statistik akhir
                await this.displayFinalStats();
                
            } catch (error) {
                console.error('Error during cleanup:', error);
            }
            
            console.log('üëã Bot ditutup. Terima kasih!');
            process.exit(0);
        });

        // Cleanup otomatis setiap 1 jam
        setInterval(async () => {
            await this.autoCleanup();
        }, 60 * 60 * 1000); // 1 jam
    }

    async autoCleanup() {
        try {
            console.log('üßπ Menjalankan pembersihan otomatis...');
            
            const tempDir = config.folders.temp;
            const files = await fs.readdir(tempDir);
            let deletedCount = 0;
            
            for (const file of files) {
                const filePath = path.join(tempDir, file);
                const stats = await fs.stat(filePath);
                const now = new Date();
                const fileAge = now - stats.mtime;
                
                // Hapus file yang lebih dari 30 menit
                if (fileAge > 30 * 60 * 1000) {
                    await fs.remove(filePath);
                    deletedCount++;
                    console.log(`üóëÔ∏è  Menghapus file lama: ${file}`);
                }
            }
            
            if (deletedCount === 0) {
                console.log('‚ú® Tidak ada file lama yang perlu dihapus');
            } else {
                console.log(`‚úÖ ${deletedCount} file lama berhasil dihapus`);
            }
            
        } catch (error) {
            console.error('Error during auto cleanup:', error);
        }
    }

    setupMonitoring() {
        // Tampilkan stats setiap 10 menit
        setInterval(async () => {
            await this.displayStats();
        }, 10 * 60 * 1000);

        // Log uptime setiap jam
        setInterval(() => {
            const uptime = new Date() - this.startTime;
            const hours = Math.floor(uptime / (1000 * 60 * 60));
            const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
            console.log(`‚è∞ Bot uptime: ${hours} jam ${minutes} menit`);
        }, 60 * 60 * 1000);
    }

    async displayStats() {
        try {
            console.log('\nüìä STATISTIK BOT:');
            console.log('==================');
            
            let totalFiles = 0;
            
            // Hitung total file di setiap kategori
            for (const [key, category] of Object.entries(config.categories)) {
                const categoryPath = path.join(config.folders.downloads, category);
                const files = await fs.readdir(categoryPath);
                const fileCount = files.length;
                totalFiles += fileCount;
                
                console.log(`üìÅ ${category}: ${fileCount} file`);
            }
            
            // Hitung ukuran folder downloads
            const folderSize = await this.getFolderSize(config.folders.downloads);
            
            console.log('==================');
            console.log(`üìã Total file: ${totalFiles}`);
            console.log(`üíæ Total ukuran: ${this.formatBytes(folderSize)}`);
            
            const uptime = new Date() - this.startTime;
            const hours = Math.floor(uptime / (1000 * 60 * 60));
            const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
            console.log(`‚è∞ Uptime: ${hours}j ${minutes}m`);
            console.log('==================\n');
            
        } catch (error) {
            console.error('Error displaying stats:', error);
        }
    }

    async displayFinalStats() {
        console.log('\nüìä STATISTIK FINAL:');
        console.log('===================');
        
        let totalFiles = 0;
        for (const [key, category] of Object.entries(config.categories)) {
            const categoryPath = path.join(config.folders.downloads, category);
            const files = await fs.readdir(categoryPath);
            totalFiles += files.length;
            console.log(`üìÅ ${category}: ${files.length} file`);
        }
        
        const totalUptime = new Date() - this.startTime;
        const hours = Math.floor(totalUptime / (1000 * 60 * 60));
        const minutes = Math.floor((totalUptime % (1000 * 60 * 60)) / (1000 * 60));
        
        console.log('===================');
        console.log(`üìã Total file didownload: ${totalFiles}`);
        console.log(`‚è∞ Total runtime: ${hours} jam ${minutes} menit`);
        console.log('===================');
    }

    async getFolderSize(folderPath) {
        let size = 0;
        
        async function calculateSize(dir) {
            const files = await fs.readdir(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stats = await fs.stat(filePath);
                
                if (stats.isDirectory()) {
                    await calculateSize(filePath);
                } else {
                    size += stats.size;
                }
            }
        }
        
        try {
            await calculateSize(folderPath);
        } catch (error) {
            console.error('Error calculating folder size:', error);
        }
        
        return size;
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// Jalankan bot
const bot = new TikTokBot();
bot.start().then(() => {
    console.log('üéâ Bot berhasil dimulai!');
    console.log('üìù Ketik Ctrl+C untuk menghentikan bot\n');
}).catch(error => {
    console.error('üí• Fatal error:', error);
    process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(1);
});